---
phase: 01-deep-analysis
plan: 01
type: execute
---

<objective>
Map the complete TTS synchronization data flow from Native Android layer through React Native to WebView, identifying all event handlers, state transitions, and communication bridges.

Purpose: Establish clear understanding of how TTS progress events flow through the 3-layer architecture to update highlights, providing foundation for root cause analysis.

Output: Documented data flow with all entry points, event handlers, state updates, and bridge communications.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# TTS Architecture (3-Layer Hybrid)
@src/screens/reader/components/WebViewReader.tsx
@src/screens/reader/hooks/useTTSController.ts
@src/services/TTSAudioManager.ts
@android/app/src/main/assets/js/core.js
@android/app/src/main/java/com/lnreader/

# Data Files
@src/screens/reader/hooks/__tests__/useTTSController.integration.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Trace Native TTS events to React Native</name>
  <files>android/app/src/main/java/com/lnreader/, src/services/TTSAudioManager.ts</files>
  <action>
Map the event flow from Native Android TTS engine to React Native:
1. Identify where native TTS fires onSpeechDone, onSpeechStart, onRangeStart events
2. Trace how TTSAudioManager receives these events via native module bridge
3. Document event payload structure (index, charOffset, charLength)
4. Identify which React Native handlers receive native events
5. Document timing and ordering guarantees (if any)

DO NOT implement any changes - this is read-only analysis.
</action>
  <verify>Document shows complete event chain: Native Kotlin → TTSAudioManager → React Native handlers with event payload structure</verify>
  <done>Clear mapping of native→RN event flow with file locations and line numbers for each handler</done>
</task>

<task type="auto">
  <name>Task 2: Trace React Native TTS events to WebView</name>
  <files>src/screens/reader/hooks/useTTSController.ts, src/screens/reader/components/WebViewReader.tsx, android/app/src/main/assets/js/core.js</files>
  <action>
Map the event flow from React Native to WebView:
1. Identify how useTTSController forwards TTS events to WebView
2. Trace ttsBridge communication methods (injectJavaScript, postMessage)
3. Document core.js APIs: window.reader.highlightElement(), window.tts.getCurrentParagraphIndex()
4. Identify where WebView updates currentParagraphIndexRef
5. Document race protection refs (wakeTransitionInProgressRef, chapterTransitionTimeRef)

DO NOT implement any changes - this is read-only analysis.
</action>
  <verify>Document shows complete event chain: RN handlers → WebView bridge → core.js APIs with method signatures</verify>
  <done>Clear mapping of RN→WebView event flow with bridge communication patterns</done>
</task>

<task type="auto">
  <name>Task 3: Document state machine transitions and queue management</name>
  <files>src/screens/reader/hooks/useTTSController.ts, src/services/TTSState.ts</files>
  <action>
Map TTS state machine and queue management:
1. Document all state transitions (IDLE → STARTING → PLAYING → REFILLING → PLAYING)
2. Identify queue refill logic (REFILL_THRESHOLD=10, MIN_BATCH_SIZE=20)
3. Document how state changes trigger event handling
4. Map queue management to highlight updates
5. Identify any state drift potential (ref vs state)

DO NOT implement any changes - this is read-only analysis.
</action>
  <verify>Document shows state machine diagram with transitions, queue refill triggers, and highlight update timing</verify>
  <done>Complete state machine documentation with queue lifecycle and highlight synchronization points</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Data flow document created with all 3 layers (Native → RN → WebView)
- [ ] Event handler mapping shows complete event chain
- [ ] State machine transitions documented
- [ ] Queue management logic mapped
- [ ] Race protection refs identified
</verification>

<success_criteria>

- Complete TTS sync data flow documented
- All event handlers mapped with file locations
- State machine transitions clear
- Queue management understood
- Bridge communication patterns documented
  </success_criteria>

<output>
After completion, create `.planning/phases/01-deep-analysis/01-01-SUMMARY.md`:

# Phase 1 Plan 1: Map TTS Sync Data Flow Summary

**Complete TTS event flow mapped from Native Android through React Native to WebView, identifying all handlers, state transitions, and bridge communications.**

## Accomplishments

- Documented Native → RN event flow (onSpeechDone/onRangeStart → TTSAudioManager → handlers)
- Documented RN → WebView flow (useTTSController → ttsBridge → core.js APIs)
- Mapped state machine transitions (IDLE → STARTING → PLAYING → REFILLING)
- Identified queue management logic (threshold=10, batch=20)
- Documented race protection refs (wakeTransitionInProgressRef, chapterTransitionTimeRef)

## Key Findings

- Event flow: Native Kotlin events → TTSAudioManager → useTTSController handlers → WebView core.js
- State tracked in: currentParagraphIndexRef (ref), currentIndex (state), MMKV, SharedPreferences
- Race protection: wakeTransitionInProgressRef guards wake-up transitions
- Bridge communication: injectJavaScript for RN→WebView, postMessage for WebView→RN

## Files Analyzed

- `android/app/src/main/java/com/lnreader/TTSHighlightModule.kt` - Native TTS events
- `src/services/TTSAudioManager.ts` - Native module wrapper
- `src/screens/reader/hooks/useTTSController.ts` - State machine and event handlers
- `src/screens/reader/components/WebViewReader.tsx` - Reader controller
- `android/app/src/main/assets/js/core.js` - WebView highlighting logic

## Next Step

Ready for 01-02-PLAN.md - Identify all progress tracking locations and reconciliation logic
</output>
