---
phase: 01-deep-analysis
plan: 02
type: execute
---

<objective>
Identify all locations where TTS progress is tracked, saved, and loaded, including the reconciliation logic that merges multiple data sources.

Purpose: Understand the complete progress tracking system to identify where +1 offset could be introduced during save/load/reconciliation operations.

Output: Complete inventory of progress tracking locations with reconciliation logic and potential drift points.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STACK.md

# From 01-01: Data flow context
@.planning/phases/01-deep-analysis/01-01-SUMMARY.md

# Progress Tracking Files
@src/hooks/persisted/useSettings.ts
@src/database/queries/ChapterQueries.ts
@src/screens/reader/hooks/useTTSController.ts
@src/screens/reader/components/WebViewReader.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Identify all progress tracking locations</name>
  <files>src/screens/reader/hooks/useTTSController.ts, src/hooks/persisted/useSettings.ts, src/database/queries/ChapterQueries.ts</files>
  <action>
Identify every location where currentParagraphIndex/progress is tracked:
1. Ref tracking: currentParagraphIndexRef, latestParagraphIndexRef in useTTSController
2. State tracking: currentIndex state in useTTSController
3. MMKV storage: Which keys store progress (search MMKV set operations)
4. Database storage: ChapterQueries.saveProgress() calls
5. Native storage: SharedPreferences writes (search native bridge calls)
6. WebView state: getCurrentParagraphIndex() in core.js

For each location, document:
- File path and line number
- Variable name / storage key
- When it's updated (which event handler)
- Update mechanism (direct assign, queue, async)

DO NOT implement any changes - this is read-only analysis.
</action>
  <verify>List shows 6+ progress tracking locations with file paths, line numbers, and update triggers</verify>
  <done>Complete inventory of all progress tracking variables and storage locations</done>
</task>

<task type="auto">
  <name>Task 2: Document progress reconciliation logic</name>
  <files>src/screens/reader/components/WebViewReader.tsx, src/screens/reader/hooks/useTTSController.ts</files>
  <action>
Map how progress is reconciled from multiple sources on load:
1. Find Math.max(dbIndex, mmkvIndex, nativeIndex) logic
2. Document which ChapterQueries methods read progress
3. Identify MMKV progress read operations
4. Document native SharedPreferences reads
5. Map reconciliation order and priority
6. Identify any fallback logic when sources disagree

For each reconciliation point, document:
- File path and line number
- Which sources are compared
- Reconciliation strategy (max, min, priority)
- Edge cases handled

DO NOT implement any changes - this is read-only analysis.
</action>
  <verify>Document shows reconciliation logic with Math.max sources and fallback strategies</verify>
  <done>Clear reconciliation flow diagram showing how multiple sources merge</done>
</task>

<task type="auto">
  <name>Task 3: Identify potential drift points between ref and state</name>
  <files>src/screens/reader/hooks/useTTSController.ts, src/screens/reader/components/WebViewReader.tsx</files>
  <action>
Identify where currentParagraphIndexRef and currentIndex state could diverge:
1. Find all locations where ref is updated without updating state
2. Find all locations where state is updated without updating ref
3. Check for async operations that could cause race conditions
4. Identify event handlers that might update one but not both
5. Document timing differences between ref and state updates
6. Check wake-up transition logic for potential drift

For each drift point, document:
- File path and line number
- Why drift could occur (race condition, missing sync)
- Impact on highlight synchronization
- Whether bug scenarios could trigger it

DO NOT implement any changes - this is read-only analysis.
</action>
  <verify>Document lists 3-5 potential drift points with scenarios that could cause +1 offset</verify>
  <done>Complete drift analysis showing how ref/state mismatch could cause highlight offset</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All progress tracking locations identified (6+ locations)
- [ ] Reconciliation logic documented (Math.max with all sources)
- [ ] Drift points between ref and state identified
- [ ] Each location has file path, line number, and update trigger
- [ ] Bug scenarios mapped to potential drift causes
</verification>

<success_criteria>

- Complete inventory of progress tracking locations
- Reconciliation logic understood (Math.max of 3 sources)
- Ref vs state drift points identified
- Potential +1 offset causes mapped
- Ready for root cause investigation (Phase 2)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-deep-analysis/01-02-SUMMARY.md`:

# Phase 1 Plan 2: Progress Tracking Analysis Summary

**Identified all progress tracking locations across 3 storage layers (Database, MMKV, Native) with reconciliation logic and mapped potential drift points between ref and state tracking.**

## Accomplishments

- Complete inventory of progress tracking: 2 refs, 1 state, 3 storage layers
- Documented reconciliation: Math.max(dbIndex, mmkvIndex, nativeIndex) on load
- Identified ref/state drift points in event handlers and async operations
- Mapped bug scenarios to potential drift causes

## Key Findings

**Progress Tracking Locations:**
- Refs: currentParagraphIndexRef, latestParagraphIndexRef
- State: currentIndex in useTTSController
- MMKV: Chapter progress keys (document specific keys)
- Database: ChapterQueries.saveProgress()
- Native: SharedPreferences (chapter_progress_{chapterId})
- WebView: core.js getCurrentParagraphIndex()

**Reconciliation Logic:**
- On load: Math.max of all 3 sources (DB, MMKV, Native)
- Priority: Highest index wins across all sources
- Potential issue: No source priority - max could pick stale data

**Drift Points:**
- Race conditions in async save operations
- Wake-up transitions with wakeTransitionInProgressRef
- Chapter transitions with pending saves
- Event handler timing (onSpeechDone before onRangeStart)

## Files Analyzed

- `src/screens/reader/hooks/useTTSController.ts` - Ref/state tracking
- `src/hooks/persisted/useSettings.ts` - MMKV operations
- `src/database/queries/ChapterQueries.ts` - Database persistence
- `src/screens/reader/components/WebViewReader.tsx` - Progress loading
- `android/app/src/main/assets/js/core.js` - WebView state

## Next Step

Phase 1 complete. Ready for Phase 2: Root Cause Investigation (02-01-PLAN.md)
</output>
